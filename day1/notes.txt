slide
https://talks.godoc.org/github.com/iporsut/gotraining-slide/basic.slide#1

How GO handle time format (เช่น const timeFormatLayout = "15:04:05 02/01/2006")
02 แทนเป็น month
01 แทนเป็นวันที่
https://medium.com/@simplyianm/how-go-solves-date-and-time-formatting-8a932117c41c

ตำแหน่งตัวแปรไหนถ้าจะไม่ใช้ ให้ใส่ _ เพราะถ้าเก็บไว้แล้วไม่ใช้ มันจะ compile error

Array vs Slice
Array: var a [5]int (fixed size)
Slice: var a []int (not fixed size)

*funct ไหนมีแนวโน้มเปลี่ยน size ของ slice จะ return pointer ใหม่ให้เราตั้ง var มารับทางซ้ายของ =
 ส่วนที่ไม่มีเปลี่ยน (เช่นแค่ sort) ก็จะไม่มี return ค่า (sort.Ints(array))

Go จะช่วยย้าย stack -> heap อัตโนมัติ ถ้าค่าโดน ref ด้วย pointer เช่นตัวอย่าง struct ปกติจะอยู่ใน stack แต่พอโดน ref แบบนี้จะเก็บใน heap แทน
func NewCustomer(name string, balance satang) *Customer {
    return &Customer{
        ID:      1, // TODO: Auto increment ID
        Name:    name,
        Balance: balance,
    } // Move to heap
}

เรื่องของ method reciever
ระวังเคส pass struct ไป method
มันรับทั้งแบบ (c *Customer) และ (c Customer) โดยถ้าเป็น (c Customer) มันจะ copy struct ไปใหม่ ถ้าแก้อะไรแล้วค่าไม่เปลี่ยนก็ต้องสลับไป (c *Customer)

ชื่อ func ขึ้นต้นด้วยตัวเล็กใช้ได้เฉพาะใน package ส่วนขึ้นต้นด้วยตัวใหญ่ใช้ข้าม package ได้

เรื่องของ Goroutine และ channel
ตัวอย่างที่น่าสนใจ
c := make(chan int)
	c <- 10
	<-c
ติด deadlock เพราะบรรทัด c <- 10 มัน block (ไปไม่ถึง <-c) ต้องย้าย c <- 10 ไป Goroutine อื่นก่อน

func sender(n int, c chan int) {
	c <- 10
}

c := make(chan int)
	go sender(10, c)
	<-c

เรื่องของ Select
- ถ้าเกิดมี ch เสร็จพร้อมกันเป๊ะๆ 2 อัน มันจะเลือกทำ 1 อันแบบสุ่ม

ตัวอย่าง 2
for {
        select {
        case t := <-chOneSec:
            fmt.Println("From one second sender:", t)
        case t := <-chFiveSec:
            fmt.Println("From five second sender:", t)
        case <-ctx.Done():
            return
        }
}
จังหวะ 5 วินาที: จะสุ่มพ่นจาก case chOneSec/chFiveSec แต่เนื่องจากมันอยู่ใน for ดังนั้น loop ต่อไปก็จะพ่นอีกอันออกทันทีอยู่ดี

เรื่องของ package sync.Mutex
ดูตัวอย่าง wordcount เอา lock จังหวะ increment กับตอน print

ใช้ done chan struct{} กับ channel trick บอกว่าวน loop จบแล้ว
ทำไมใช้ struct{} เพราะใช้ memory size = 0 ประหยัดสุด

sync.WaitGroup ใช้แทนท่ารอ empty struct ดีกว่า
บาง func ไปใช้ของเรา แต่ไม่มี WaitGroup.Done() ให้ ก็ wrap ด้วย
func (){
   defer waitGroup.Done()
   someFunction()
}()